{"ast":null,"code":"/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\n'use strict';\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\kanli\\\\Documents\\\\react\\\\test\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _ = require('underscore');\n\nvar errors = require('web3-core-helpers').errors;\n\nvar formatters = require('web3-core-helpers').formatters;\n\nvar utils = require('web3-utils');\n\nvar promiEvent = require('web3-core-promievent');\n\nvar Subscriptions = require('web3-core-subscriptions').subscriptions;\n\nvar Method = function Method(options) {\n  if (!options.call || !options.name) {\n    throw new Error('When creating a method you need to provide at least the \"name\" and \"call\" property.');\n  }\n\n  this.name = options.name;\n  this.call = options.call;\n  this.params = options.params || 0;\n  this.inputFormatter = options.inputFormatter;\n  this.outputFormatter = options.outputFormatter;\n  this.transformPayload = options.transformPayload;\n  this.extraFormatters = options.extraFormatters;\n  this.requestManager = options.requestManager; // reference to eth.accounts\n\n  this.accounts = options.accounts;\n  this.defaultBlock = options.defaultBlock || 'latest';\n  this.defaultAccount = options.defaultAccount || null;\n  this.transactionBlockTimeout = options.transactionBlockTimeout || 50;\n  this.transactionConfirmationBlocks = options.transactionConfirmationBlocks || 24;\n  this.transactionPollingTimeout = options.transactionPollingTimeout || 750;\n  this.defaultCommon = options.defaultCommon;\n  this.defaultChain = options.defaultChain;\n  this.defaultHardfork = options.defaultHardfork;\n};\n\nMethod.prototype.setRequestManager = function (requestManager, accounts) {\n  this.requestManager = requestManager; // reference to eth.accounts\n\n  if (accounts) {\n    this.accounts = accounts;\n  }\n};\n\nMethod.prototype.createFunction = function (requestManager, accounts) {\n  var func = this.buildCall();\n  func.call = this.call;\n  this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts);\n  return func;\n};\n\nMethod.prototype.attachToObject = function (obj) {\n  var func = this.buildCall();\n  func.call = this.call;\n  var name = this.name.split('.');\n\n  if (name.length > 1) {\n    obj[name[0]] = obj[name[0]] || {};\n    obj[name[0]][name[1]] = func;\n  } else {\n    obj[name[0]] = func;\n  }\n};\n/**\n * Should be used to determine name of the jsonrpc method based on arguments\n *\n * @method getCall\n * @param {Array} arguments\n * @return {String} name of jsonrpc method\n */\n\n\nMethod.prototype.getCall = function (args) {\n  return _.isFunction(this.call) ? this.call(args) : this.call;\n};\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\n\n\nMethod.prototype.extractCallback = function (args) {\n  if (_.isFunction(args[args.length - 1])) {\n    return args.pop(); // modify the args array!\n  }\n};\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\n\n\nMethod.prototype.validateArgs = function (args) {\n  if (args.length !== this.params) {\n    throw errors.InvalidNumberOfParams(args.length, this.params, this.name);\n  }\n};\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\n\n\nMethod.prototype.formatInput = function (args) {\n  var _this = this;\n\n  if (!this.inputFormatter) {\n    return args;\n  }\n\n  return this.inputFormatter.map(function (formatter, index) {\n    // bind this for defaultBlock, and defaultAccount\n    return formatter ? formatter.call(_this, args[index]) : args[index];\n  });\n};\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */\n\n\nMethod.prototype.formatOutput = function (result) {\n  var _this = this;\n\n  if (_.isArray(result)) {\n    return result.map(function (res) {\n      return _this.outputFormatter && res ? _this.outputFormatter(res) : res;\n    });\n  } else {\n    return this.outputFormatter && result ? this.outputFormatter(result) : result;\n  }\n};\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\n\n\nMethod.prototype.toPayload = function (args) {\n  var call = this.getCall(args);\n  var callback = this.extractCallback(args);\n  var params = this.formatInput(args);\n  this.validateArgs(params);\n  var payload = {\n    method: call,\n    params: params,\n    callback: callback\n  };\n\n  if (this.transformPayload) {\n    payload = this.transformPayload(payload);\n  }\n\n  return payload;\n};\n\nMethod.prototype._confirmTransaction = function (defer, result, payload) {\n  var method = this,\n      promiseResolved = false,\n      canUnsubscribe = true,\n      timeoutCount = 0,\n      confirmationCount = 0,\n      intervalId = null,\n      lastBlock = null,\n      receiptJSON = '',\n      gasProvided = _.isObject(payload.params[0]) && payload.params[0].gas ? payload.params[0].gas : null,\n      isContractDeployment = _.isObject(payload.params[0]) && payload.params[0].data && payload.params[0].from && !payload.params[0].to; // add custom send Methods\n\n  var _ethereumCalls = [new Method({\n    name: 'getBlockByNumber',\n    call: 'eth_getBlockByNumber',\n    params: 2,\n    inputFormatter: [formatters.inputBlockNumberFormatter, function (val) {\n      return !!val;\n    }],\n    outputFormatter: formatters.outputBlockFormatter\n  }), new Method({\n    name: 'getTransactionReceipt',\n    call: 'eth_getTransactionReceipt',\n    params: 1,\n    inputFormatter: [null],\n    outputFormatter: formatters.outputTransactionReceiptFormatter\n  }), new Method({\n    name: 'getCode',\n    call: 'eth_getCode',\n    params: 2,\n    inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]\n  }), new Subscriptions({\n    name: 'subscribe',\n    type: 'eth',\n    subscriptions: {\n      'newBlockHeaders': {\n        subscriptionName: 'newHeads',\n        // replace subscription with this name\n        params: 0,\n        outputFormatter: formatters.outputBlockFormatter\n      }\n    }\n  })]; // attach methods to this._ethereumCall\n\n  var _ethereumCall = {};\n\n  _.each(_ethereumCalls, function (mthd) {\n    mthd.attachToObject(_ethereumCall);\n    mthd.requestManager = method.requestManager; // assign rather than call setRequestManager()\n  }); // fire \"receipt\" and confirmation events and resolve after\n\n\n  var checkConfirmation = function checkConfirmation(existingReceipt, isPolling, err, blockHeader, sub) {\n    if (!err) {\n      // create fake unsubscribe\n      if (!sub) {\n        sub = {\n          unsubscribe: function unsubscribe() {\n            clearInterval(intervalId);\n          }\n        };\n      } // if we have a valid receipt we don't need to send a request\n\n\n      return (existingReceipt ? promiEvent.resolve(existingReceipt) : _ethereumCall.getTransactionReceipt(result)). // catch error from requesting receipt\n      catch(function (err) {\n        sub.unsubscribe();\n        promiseResolved = true;\n\n        utils._fireError({\n          message: 'Failed to check for transaction receipt:',\n          data: err\n        }, defer.eventEmitter, defer.reject);\n      }) // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\n      .then(function _callee(receipt) {\n        var block;\n        return _regeneratorRuntime.async(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(!receipt || !receipt.blockHash)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new Error('Receipt missing or blockHash null');\n\n              case 2:\n                // apply extra formatters\n                if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\n                  receipt = method.extraFormatters.receiptFormatter(receipt);\n                } // check if confirmation listener exists\n\n\n                if (!(defer.eventEmitter.listeners('confirmation').length > 0)) {\n                  _context.next = 24;\n                  break;\n                }\n\n                if (!(existingReceipt === undefined || confirmationCount !== 0)) {\n                  _context.next = 21;\n                  break;\n                }\n\n                if (!isPolling) {\n                  _context.next = 20;\n                  break;\n                }\n\n                if (!lastBlock) {\n                  _context.next = 13;\n                  break;\n                }\n\n                _context.next = 9;\n                return _regeneratorRuntime.awrap(_ethereumCall.getBlockByNumber(lastBlock.number + 1));\n\n              case 9:\n                block = _context.sent;\n\n                if (block) {\n                  lastBlock = block;\n                  defer.eventEmitter.emit('confirmation', confirmationCount, receipt);\n                }\n\n                _context.next = 18;\n                break;\n\n              case 13:\n                _context.next = 15;\n                return _regeneratorRuntime.awrap(_ethereumCall.getBlockByNumber(receipt.blockNumber));\n\n              case 15:\n                block = _context.sent;\n                lastBlock = block;\n                defer.eventEmitter.emit('confirmation', confirmationCount, receipt);\n\n              case 18:\n                _context.next = 21;\n                break;\n\n              case 20:\n                defer.eventEmitter.emit('confirmation', confirmationCount, receipt);\n\n              case 21:\n                if (isPolling && block || !isPolling) {\n                  confirmationCount++;\n                }\n\n                canUnsubscribe = false;\n\n                if (confirmationCount === method.transactionConfirmationBlocks + 1) {\n                  // add 1 so we account for conf 0\n                  sub.unsubscribe();\n                  defer.eventEmitter.removeAllListeners();\n                }\n\n              case 24:\n                return _context.abrupt(\"return\", receipt);\n\n              case 25:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        });\n      }) // CHECK for CONTRACT DEPLOYMENT\n      .then(function (receipt) {\n        if (isContractDeployment && !promiseResolved) {\n          if (!receipt.contractAddress) {\n            if (canUnsubscribe) {\n              sub.unsubscribe();\n              promiseResolved = true;\n            }\n\n            utils._fireError(new Error('The transaction receipt didn\\'t contain a contract address.'), defer.eventEmitter, defer.reject, null, receipt);\n\n            return;\n          }\n\n          _ethereumCall.getCode(receipt.contractAddress, function (e, code) {\n            if (!code) {\n              return;\n            }\n\n            if (code.length > 2) {\n              defer.eventEmitter.emit('receipt', receipt); // if contract, return instance instead of receipt\n\n              if (method.extraFormatters && method.extraFormatters.contractDeployFormatter) {\n                defer.resolve(method.extraFormatters.contractDeployFormatter(receipt));\n              } else {\n                defer.resolve(receipt);\n              } // need to remove listeners, as they aren't removed automatically when succesfull\n\n\n              if (canUnsubscribe) {\n                defer.eventEmitter.removeAllListeners();\n              }\n            } else {\n              utils._fireError(new Error('The contract code couldn\\'t be stored, please check your gas limit.'), defer.eventEmitter, defer.reject, null, receipt);\n            }\n\n            if (canUnsubscribe) {\n              sub.unsubscribe();\n            }\n\n            promiseResolved = true;\n          });\n        }\n\n        return receipt;\n      }) // CHECK for normal tx check for receipt only\n      .then(function (receipt) {\n        if (!isContractDeployment && !promiseResolved) {\n          if (!receipt.outOfGas && (!gasProvided || gasProvided !== receipt.gasUsed) && (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined')) {\n            defer.eventEmitter.emit('receipt', receipt);\n            defer.resolve(receipt); // need to remove listeners, as they aren't removed automatically when succesfull\n\n            if (canUnsubscribe) {\n              defer.eventEmitter.removeAllListeners();\n            }\n          } else {\n            receiptJSON = JSON.stringify(receipt, null, 2);\n\n            if (receipt.status === false || receipt.status === '0x0') {\n              utils._fireError(new Error('Transaction has been reverted by the EVM:\\n' + receiptJSON), defer.eventEmitter, defer.reject, null, receipt);\n            } else {\n              utils._fireError(new Error('Transaction ran out of gas. Please provide more gas:\\n' + receiptJSON), defer.eventEmitter, defer.reject, null, receipt);\n            }\n          }\n\n          if (canUnsubscribe) {\n            sub.unsubscribe();\n          }\n\n          promiseResolved = true;\n        }\n      }) // time out the transaction if not mined after 50 blocks\n      .catch(function () {\n        timeoutCount++; // check to see if we are http polling\n\n        if (!!isPolling) {\n          // polling timeout is different than transactionBlockTimeout blocks since we are triggering every second\n          if (timeoutCount - 1 >= method.transactionPollingTimeout) {\n            sub.unsubscribe();\n            promiseResolved = true;\n\n            utils._fireError(new Error('Transaction was not mined within ' + method.transactionPollingTimeout + ' seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n          }\n        } else {\n          if (timeoutCount - 1 >= method.transactionBlockTimeout) {\n            sub.unsubscribe();\n            promiseResolved = true;\n\n            utils._fireError(new Error('Transaction was not mined within ' + method.transactionBlockTimeout + ' blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n          }\n        }\n      });\n    } else {\n      sub.unsubscribe();\n      promiseResolved = true;\n\n      utils._fireError({\n        message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.',\n        data: err\n      }, defer.eventEmitter, defer.reject);\n    }\n  }; // start watching for confirmation depending on the support features of the provider\n\n\n  var startWatching = function (existingReceipt) {\n    // if provider allows PUB/SUB\n    if (_.isFunction(this.requestManager.provider.on)) {\n      _ethereumCall.subscribe('newBlockHeaders', checkConfirmation.bind(null, existingReceipt, false));\n    } else {\n      intervalId = setInterval(checkConfirmation.bind(null, existingReceipt, true), 1000);\n    }\n  }.bind(this); // first check if we already have a confirmed transaction\n\n\n  _ethereumCall.getTransactionReceipt(result).then(function (receipt) {\n    if (receipt && receipt.blockHash) {\n      if (defer.eventEmitter.listeners('confirmation').length > 0) {\n        // We must keep on watching for new Blocks, if a confirmation listener is present\n        startWatching(receipt);\n      }\n\n      checkConfirmation(receipt, false);\n    } else if (!promiseResolved) {\n      startWatching();\n    }\n  }).catch(function () {\n    if (!promiseResolved) startWatching();\n  });\n};\n\nvar getWallet = function getWallet(from, accounts) {\n  var wallet = null; // is index given\n\n  if (_.isNumber(from)) {\n    wallet = accounts.wallet[from]; // is account given\n  } else if (_.isObject(from) && from.address && from.privateKey) {\n    wallet = from; // search in wallet for address\n  } else {\n    wallet = accounts.wallet[from.toLowerCase()];\n  }\n\n  return wallet;\n};\n\nMethod.prototype.buildCall = function () {\n  var method = this,\n      isSendTx = method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction'; // || method.call === 'personal_sendTransaction'\n  // actual send function\n\n  var send = function send() {\n    var defer = promiEvent(!isSendTx),\n        payload = method.toPayload(Array.prototype.slice.call(arguments)); // CALLBACK function\n\n    var sendTxCallback = function sendTxCallback(err, result) {\n      try {\n        result = method.formatOutput(result);\n      } catch (e) {\n        err = e;\n      }\n\n      if (result instanceof Error) {\n        err = result;\n      }\n\n      if (!err) {\n        if (payload.callback) {\n          payload.callback(null, result);\n        }\n      } else {\n        if (err.error) {\n          err = err.error;\n        }\n\n        return utils._fireError(err, defer.eventEmitter, defer.reject, payload.callback);\n      } // return PROMISE\n\n\n      if (!isSendTx) {\n        if (!err) {\n          defer.resolve(result);\n        } // return PROMIEVENT\n\n      } else {\n        defer.eventEmitter.emit('transactionHash', result);\n\n        method._confirmTransaction(defer, result, payload);\n      }\n    }; // SENDS the SIGNED SIGNATURE\n\n\n    var sendSignedTx = function sendSignedTx(sign) {\n      var signedPayload = _.extend({}, payload, {\n        method: 'eth_sendRawTransaction',\n        params: [sign.rawTransaction]\n      });\n\n      method.requestManager.send(signedPayload, sendTxCallback);\n    };\n\n    var sendRequest = function sendRequest(payload, method) {\n      if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\n        var wallet; // ETH_SENDTRANSACTION\n\n        if (payload.method === 'eth_sendTransaction') {\n          var tx = payload.params[0];\n          wallet = getWallet(_.isObject(tx) ? tx.from : null, method.accounts); // If wallet was found, sign tx, and send using sendRawTransaction\n\n          if (wallet && wallet.privateKey) {\n            var txOptions = _.omit(tx, 'from');\n\n            if (method.defaultChain && !txOptions.chain) {\n              txOptions.chain = method.defaultChain;\n            }\n\n            if (method.defaultHardfork && !txOptions.hardfork) {\n              txOptions.hardfork = method.defaultHardfork;\n            }\n\n            if (method.defaultCommon && !txOptions.common) {\n              txOptions.common = method.defaultCommon;\n            }\n\n            return method.accounts.signTransaction(txOptions, wallet.privateKey).then(sendSignedTx).catch(function (err) {\n              if (_.isFunction(defer.eventEmitter.listeners) && defer.eventEmitter.listeners('error').length) {\n                defer.eventEmitter.emit('error', err);\n                defer.eventEmitter.removeAllListeners();\n                defer.eventEmitter.catch(function () {});\n              }\n\n              defer.reject(err);\n            });\n          } // ETH_SIGN\n\n        } else if (payload.method === 'eth_sign') {\n          var data = payload.params[1];\n          wallet = getWallet(payload.params[0], method.accounts); // If wallet was found, sign tx, and send using sendRawTransaction\n\n          if (wallet && wallet.privateKey) {\n            var sign = method.accounts.sign(data, wallet.privateKey);\n\n            if (payload.callback) {\n              payload.callback(null, sign.signature);\n            }\n\n            defer.resolve(sign.signature);\n            return;\n          }\n        }\n      }\n\n      return method.requestManager.send(payload, sendTxCallback);\n    }; // Send the actual transaction\n\n\n    if (isSendTx && _.isObject(payload.params[0]) && typeof payload.params[0].gasPrice === 'undefined') {\n      var getGasPrice = new Method({\n        name: 'getGasPrice',\n        call: 'eth_gasPrice',\n        params: 0\n      }).createFunction(method.requestManager);\n      getGasPrice(function (err, gasPrice) {\n        if (gasPrice) {\n          payload.params[0].gasPrice = gasPrice;\n        }\n\n        sendRequest(payload, method);\n      });\n    } else {\n      sendRequest(payload, method);\n    }\n\n    return defer.eventEmitter;\n  }; // necessary to attach things to the method\n\n\n  send.method = method; // necessary for batch requests\n\n  send.request = this.request.bind(this);\n  return send;\n};\n/**\n * Should be called to create the pure JSONRPC request which can be used in a batch request\n *\n * @method request\n * @return {Object} jsonrpc request\n */\n\n\nMethod.prototype.request = function () {\n  var payload = this.toPayload(Array.prototype.slice.call(arguments));\n  payload.format = this.formatOutput.bind(this);\n  return payload;\n};\n\nmodule.exports = Method;","map":{"version":3,"sources":["C:/Users/kanli/Documents/react/test/node_modules/web3-core-method/src/index.js"],"names":["_","require","errors","formatters","utils","promiEvent","Subscriptions","subscriptions","Method","options","call","name","Error","params","inputFormatter","outputFormatter","transformPayload","extraFormatters","requestManager","accounts","defaultBlock","defaultAccount","transactionBlockTimeout","transactionConfirmationBlocks","transactionPollingTimeout","defaultCommon","defaultChain","defaultHardfork","prototype","setRequestManager","createFunction","func","buildCall","attachToObject","obj","split","length","getCall","args","isFunction","extractCallback","pop","validateArgs","InvalidNumberOfParams","formatInput","_this","map","formatter","index","formatOutput","result","isArray","res","toPayload","callback","payload","method","_confirmTransaction","defer","promiseResolved","canUnsubscribe","timeoutCount","confirmationCount","intervalId","lastBlock","receiptJSON","gasProvided","isObject","gas","isContractDeployment","data","from","to","_ethereumCalls","inputBlockNumberFormatter","val","outputBlockFormatter","outputTransactionReceiptFormatter","inputAddressFormatter","inputDefaultBlockNumberFormatter","type","subscriptionName","_ethereumCall","each","mthd","checkConfirmation","existingReceipt","isPolling","err","blockHeader","sub","unsubscribe","clearInterval","resolve","getTransactionReceipt","catch","_fireError","message","eventEmitter","reject","then","receipt","blockHash","receiptFormatter","listeners","undefined","getBlockByNumber","number","block","emit","blockNumber","removeAllListeners","contractAddress","getCode","e","code","contractDeployFormatter","outOfGas","gasUsed","status","JSON","stringify","startWatching","provider","on","subscribe","bind","setInterval","getWallet","wallet","isNumber","address","privateKey","toLowerCase","isSendTx","send","Array","slice","arguments","sendTxCallback","error","sendSignedTx","sign","signedPayload","extend","rawTransaction","sendRequest","tx","txOptions","omit","chain","hardfork","common","signTransaction","signature","gasPrice","getGasPrice","request","format","module","exports"],"mappings":"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","sourcesContent":["/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\n\n'use strict';\n\nvar _ = require('underscore');\nvar errors = require('web3-core-helpers').errors;\nvar formatters = require('web3-core-helpers').formatters;\nvar utils = require('web3-utils');\nvar promiEvent = require('web3-core-promievent');\nvar Subscriptions = require('web3-core-subscriptions').subscriptions;\n\nvar Method = function Method(options) {\n\n    if (!options.call || !options.name) {\n        throw new Error('When creating a method you need to provide at least the \"name\" and \"call\" property.');\n    }\n\n    this.name = options.name;\n    this.call = options.call;\n    this.params = options.params || 0;\n    this.inputFormatter = options.inputFormatter;\n    this.outputFormatter = options.outputFormatter;\n    this.transformPayload = options.transformPayload;\n    this.extraFormatters = options.extraFormatters;\n\n    this.requestManager = options.requestManager;\n\n    // reference to eth.accounts\n    this.accounts = options.accounts;\n\n    this.defaultBlock = options.defaultBlock || 'latest';\n    this.defaultAccount = options.defaultAccount || null;\n    this.transactionBlockTimeout = options.transactionBlockTimeout || 50;\n    this.transactionConfirmationBlocks = options.transactionConfirmationBlocks || 24;\n    this.transactionPollingTimeout = options.transactionPollingTimeout || 750;\n    this.defaultCommon = options.defaultCommon;\n    this.defaultChain = options.defaultChain;\n    this.defaultHardfork = options.defaultHardfork;\n};\n\nMethod.prototype.setRequestManager = function(requestManager, accounts) {\n    this.requestManager = requestManager;\n\n    // reference to eth.accounts\n    if (accounts) {\n        this.accounts = accounts;\n    }\n\n};\n\nMethod.prototype.createFunction = function(requestManager, accounts) {\n    var func = this.buildCall();\n    func.call = this.call;\n\n    this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts);\n\n    return func;\n};\n\nMethod.prototype.attachToObject = function(obj) {\n    var func = this.buildCall();\n    func.call = this.call;\n    var name = this.name.split('.');\n    if (name.length > 1) {\n        obj[name[0]] = obj[name[0]] || {};\n        obj[name[0]][name[1]] = func;\n    } else {\n        obj[name[0]] = func;\n    }\n};\n\n/**\n * Should be used to determine name of the jsonrpc method based on arguments\n *\n * @method getCall\n * @param {Array} arguments\n * @return {String} name of jsonrpc method\n */\nMethod.prototype.getCall = function(args) {\n    return _.isFunction(this.call) ? this.call(args) : this.call;\n};\n\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\nMethod.prototype.extractCallback = function(args) {\n    if (_.isFunction(args[args.length - 1])) {\n        return args.pop(); // modify the args array!\n    }\n};\n\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\nMethod.prototype.validateArgs = function(args) {\n    if (args.length !== this.params) {\n        throw errors.InvalidNumberOfParams(args.length, this.params, this.name);\n    }\n};\n\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\nMethod.prototype.formatInput = function(args) {\n    var _this = this;\n\n    if (!this.inputFormatter) {\n        return args;\n    }\n\n    return this.inputFormatter.map(function(formatter, index) {\n        // bind this for defaultBlock, and defaultAccount\n        return formatter ? formatter.call(_this, args[index]) : args[index];\n    });\n};\n\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */\nMethod.prototype.formatOutput = function(result) {\n    var _this = this;\n\n    if (_.isArray(result)) {\n        return result.map(function(res) {\n            return _this.outputFormatter && res ? _this.outputFormatter(res) : res;\n        });\n    } else {\n        return this.outputFormatter && result ? this.outputFormatter(result) : result;\n    }\n};\n\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\nMethod.prototype.toPayload = function(args) {\n    var call = this.getCall(args);\n    var callback = this.extractCallback(args);\n    var params = this.formatInput(args);\n    this.validateArgs(params);\n\n    var payload = {\n        method: call,\n        params: params,\n        callback: callback\n    };\n\n    if (this.transformPayload) {\n        payload = this.transformPayload(payload);\n    }\n\n    return payload;\n};\n\n\nMethod.prototype._confirmTransaction = function(defer, result, payload) {\n    var method = this,\n        promiseResolved = false,\n        canUnsubscribe = true,\n        timeoutCount = 0,\n        confirmationCount = 0,\n        intervalId = null,\n        lastBlock = null,\n        receiptJSON = '',\n        gasProvided = (_.isObject(payload.params[0]) && payload.params[0].gas) ? payload.params[0].gas : null,\n        isContractDeployment = _.isObject(payload.params[0]) &&\n            payload.params[0].data &&\n            payload.params[0].from &&\n            !payload.params[0].to;\n\n    // add custom send Methods\n    var _ethereumCalls = [\n        new Method({\n            name: 'getBlockByNumber',\n            call: 'eth_getBlockByNumber',\n            params: 2,\n            inputFormatter: [formatters.inputBlockNumberFormatter, function(val) {\n                return !!val;\n            }],\n            outputFormatter: formatters.outputBlockFormatter\n        }),\n        new Method({\n            name: 'getTransactionReceipt',\n            call: 'eth_getTransactionReceipt',\n            params: 1,\n            inputFormatter: [null],\n            outputFormatter: formatters.outputTransactionReceiptFormatter\n        }),\n        new Method({\n            name: 'getCode',\n            call: 'eth_getCode',\n            params: 2,\n            inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]\n        }),\n        new Subscriptions({\n            name: 'subscribe',\n            type: 'eth',\n            subscriptions: {\n                'newBlockHeaders': {\n                    subscriptionName: 'newHeads', // replace subscription with this name\n                    params: 0,\n                    outputFormatter: formatters.outputBlockFormatter\n                }\n            }\n        })\n    ];\n    // attach methods to this._ethereumCall\n    var _ethereumCall = {};\n    _.each(_ethereumCalls, function(mthd) {\n        mthd.attachToObject(_ethereumCall);\n        mthd.requestManager = method.requestManager; // assign rather than call setRequestManager()\n    });\n\n\n    // fire \"receipt\" and confirmation events and resolve after\n    var checkConfirmation = function(existingReceipt, isPolling, err, blockHeader, sub) {\n        if (!err) {\n            // create fake unsubscribe\n            if (!sub) {\n                sub = {\n                    unsubscribe: function() {\n                        clearInterval(intervalId);\n                    }\n                };\n            }\n            // if we have a valid receipt we don't need to send a request\n            return (existingReceipt ? promiEvent.resolve(existingReceipt) : _ethereumCall.getTransactionReceipt(result))\n            // catch error from requesting receipt\n                .catch(function(err) {\n                    sub.unsubscribe();\n                    promiseResolved = true;\n                    utils._fireError(\n                        {\n                            message: 'Failed to check for transaction receipt:',\n                            data: err\n                        },\n                        defer.eventEmitter,\n                        defer.reject\n                    );\n                })\n                // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\n                .then(async function(receipt) {\n                    if (!receipt || !receipt.blockHash) {\n                        throw new Error('Receipt missing or blockHash null');\n                    }\n\n                    // apply extra formatters\n                    if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\n                        receipt = method.extraFormatters.receiptFormatter(receipt);\n                    }\n\n                    // check if confirmation listener exists\n                    if (defer.eventEmitter.listeners('confirmation').length > 0) {\n                        var block;\n\n                        // If there was an immediately retrieved receipt, it's already\n                        // been confirmed by the direct call to checkConfirmation needed\n                        // for parity instant-seal\n                        if (existingReceipt === undefined || confirmationCount !== 0) {\n                            if (isPolling) { // Check if actually a new block is existing on polling\n                                if (lastBlock) {\n                                    block = await _ethereumCall.getBlockByNumber(lastBlock.number + 1);\n                                    if (block) {\n                                        lastBlock = block;\n                                        defer.eventEmitter.emit('confirmation', confirmationCount, receipt);\n                                    }\n                                } else {\n                                    block = await _ethereumCall.getBlockByNumber(receipt.blockNumber);\n                                    lastBlock = block;\n                                    defer.eventEmitter.emit('confirmation', confirmationCount, receipt);\n                                }\n                            } else {\n                                defer.eventEmitter.emit('confirmation', confirmationCount, receipt);\n                            }\n                        }\n\n                        if ((isPolling && block) || !isPolling) {\n                            confirmationCount++;\n                        }\n                        canUnsubscribe = false;\n\n                        if (confirmationCount === method.transactionConfirmationBlocks + 1) { // add 1 so we account for conf 0\n                            sub.unsubscribe();\n                            defer.eventEmitter.removeAllListeners();\n                        }\n                    }\n\n                    return receipt;\n                })\n                // CHECK for CONTRACT DEPLOYMENT\n                .then(function(receipt) {\n\n                    if (isContractDeployment && !promiseResolved) {\n\n                        if (!receipt.contractAddress) {\n\n                            if (canUnsubscribe) {\n                                sub.unsubscribe();\n                                promiseResolved = true;\n                            }\n\n                            utils._fireError(\n                                new Error('The transaction receipt didn\\'t contain a contract address.'),\n                                defer.eventEmitter,\n                                defer.reject,\n                                null,\n                                receipt\n                            );\n                            return;\n                        }\n\n                        _ethereumCall.getCode(receipt.contractAddress, function(e, code) {\n\n                            if (!code) {\n                                return;\n                            }\n\n\n                            if (code.length > 2) {\n                                defer.eventEmitter.emit('receipt', receipt);\n\n                                // if contract, return instance instead of receipt\n                                if (method.extraFormatters && method.extraFormatters.contractDeployFormatter) {\n                                    defer.resolve(method.extraFormatters.contractDeployFormatter(receipt));\n                                } else {\n                                    defer.resolve(receipt);\n                                }\n\n                                // need to remove listeners, as they aren't removed automatically when succesfull\n                                if (canUnsubscribe) {\n                                    defer.eventEmitter.removeAllListeners();\n                                }\n\n                            } else {\n                                utils._fireError(\n                                    new Error('The contract code couldn\\'t be stored, please check your gas limit.'),\n                                    defer.eventEmitter,\n                                    defer.reject,\n                                    null,\n                                    receipt\n                                );\n                            }\n\n                            if (canUnsubscribe) {\n                                sub.unsubscribe();\n                            }\n                            promiseResolved = true;\n                        });\n                    }\n\n                    return receipt;\n                })\n                // CHECK for normal tx check for receipt only\n                .then(function(receipt) {\n                    if (!isContractDeployment && !promiseResolved) {\n                        if (!receipt.outOfGas &&\n                            (!gasProvided || gasProvided !== receipt.gasUsed) &&\n                            (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined')) {\n                            defer.eventEmitter.emit('receipt', receipt);\n                            defer.resolve(receipt);\n\n                            // need to remove listeners, as they aren't removed automatically when succesfull\n                            if (canUnsubscribe) {\n                                defer.eventEmitter.removeAllListeners();\n                            }\n\n                        } else {\n                            receiptJSON = JSON.stringify(receipt, null, 2);\n\n                            if (receipt.status === false || receipt.status === '0x0') {\n                                utils._fireError(\n                                    new Error('Transaction has been reverted by the EVM:\\n' + receiptJSON),\n                                    defer.eventEmitter,\n                                    defer.reject,\n                                    null,\n                                    receipt\n                                );\n                            } else {\n                                utils._fireError(\n                                    new Error('Transaction ran out of gas. Please provide more gas:\\n' + receiptJSON),\n                                    defer.eventEmitter,\n                                    defer.reject,\n                                    null,\n                                    receipt\n                                );\n                            }\n                        }\n\n                        if (canUnsubscribe) {\n                            sub.unsubscribe();\n                        }\n                        promiseResolved = true;\n                    }\n\n                })\n                // time out the transaction if not mined after 50 blocks\n                .catch(function() {\n                    timeoutCount++;\n\n                    // check to see if we are http polling\n                    if (!!isPolling) {\n                        // polling timeout is different than transactionBlockTimeout blocks since we are triggering every second\n                        if (timeoutCount - 1 >= method.transactionPollingTimeout) {\n                            sub.unsubscribe();\n                            promiseResolved = true;\n                            utils._fireError(\n                                new Error('Transaction was not mined within ' + method.transactionPollingTimeout + ' seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!'),\n                                defer.eventEmitter,\n                                defer.reject\n                            );\n                        }\n                    } else {\n                        if (timeoutCount - 1 >= method.transactionBlockTimeout) {\n                            sub.unsubscribe();\n                            promiseResolved = true;\n                            utils._fireError(\n                                new Error('Transaction was not mined within ' + method.transactionBlockTimeout + ' blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'),\n                                defer.eventEmitter,\n                                defer.reject\n                            );\n                        }\n                    }\n                });\n\n\n        } else {\n            sub.unsubscribe();\n            promiseResolved = true;\n            utils._fireError({\n                message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.',\n                data: err\n            }, defer.eventEmitter, defer.reject);\n        }\n    };\n\n    // start watching for confirmation depending on the support features of the provider\n    var startWatching = function(existingReceipt) {\n        // if provider allows PUB/SUB\n        if (_.isFunction(this.requestManager.provider.on)) {\n            _ethereumCall.subscribe('newBlockHeaders', checkConfirmation.bind(null, existingReceipt, false));\n        } else {\n            intervalId = setInterval(checkConfirmation.bind(null, existingReceipt, true), 1000);\n        }\n    }.bind(this);\n\n\n    // first check if we already have a confirmed transaction\n    _ethereumCall.getTransactionReceipt(result)\n        .then(function(receipt) {\n            if (receipt && receipt.blockHash) {\n                if (defer.eventEmitter.listeners('confirmation').length > 0) {\n                    // We must keep on watching for new Blocks, if a confirmation listener is present\n                    startWatching(receipt);\n                }\n                checkConfirmation(receipt, false);\n\n            } else if (!promiseResolved) {\n                startWatching();\n            }\n        })\n        .catch(function() {\n            if (!promiseResolved) startWatching();\n        });\n\n};\n\n\nvar getWallet = function(from, accounts) {\n    var wallet = null;\n\n    // is index given\n    if (_.isNumber(from)) {\n        wallet = accounts.wallet[from];\n\n        // is account given\n    } else if (_.isObject(from) && from.address && from.privateKey) {\n        wallet = from;\n\n        // search in wallet for address\n    } else {\n        wallet = accounts.wallet[from.toLowerCase()];\n    }\n\n    return wallet;\n};\n\nMethod.prototype.buildCall = function() {\n    var method = this,\n        isSendTx = (method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction'); // || method.call === 'personal_sendTransaction'\n\n    // actual send function\n    var send = function() {\n        var defer = promiEvent(!isSendTx),\n            payload = method.toPayload(Array.prototype.slice.call(arguments));\n\n\n        // CALLBACK function\n        var sendTxCallback = function(err, result) {\n            try {\n                result = method.formatOutput(result);\n            } catch (e) {\n                err = e;\n            }\n\n            if (result instanceof Error) {\n                err = result;\n            }\n\n            if (!err) {\n                if (payload.callback) {\n                    payload.callback(null, result);\n                }\n            } else {\n                if (err.error) {\n                    err = err.error;\n                }\n\n                return utils._fireError(err, defer.eventEmitter, defer.reject, payload.callback);\n            }\n\n            // return PROMISE\n            if (!isSendTx) {\n\n                if (!err) {\n                    defer.resolve(result);\n\n                }\n\n                // return PROMIEVENT\n            } else {\n                defer.eventEmitter.emit('transactionHash', result);\n\n                method._confirmTransaction(defer, result, payload);\n            }\n\n        };\n\n        // SENDS the SIGNED SIGNATURE\n        var sendSignedTx = function(sign) {\n\n            var signedPayload = _.extend({}, payload, {\n                method: 'eth_sendRawTransaction',\n                params: [sign.rawTransaction]\n            });\n\n            method.requestManager.send(signedPayload, sendTxCallback);\n        };\n\n\n        var sendRequest = function(payload, method) {\n\n            if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\n                var wallet;\n\n                // ETH_SENDTRANSACTION\n                if (payload.method === 'eth_sendTransaction') {\n                    var tx = payload.params[0];\n                    wallet = getWallet((_.isObject(tx)) ? tx.from : null, method.accounts);\n\n\n                    // If wallet was found, sign tx, and send using sendRawTransaction\n                    if (wallet && wallet.privateKey) {\n                        var txOptions = _.omit(tx, 'from');\n\n                        if (method.defaultChain && !txOptions.chain) {\n                            txOptions.chain = method.defaultChain;\n                        }\n\n                        if (method.defaultHardfork && !txOptions.hardfork) {\n                            txOptions.hardfork = method.defaultHardfork;\n                        }\n\n                        if (method.defaultCommon && !txOptions.common) {\n                            txOptions.common = method.defaultCommon;\n                        }\n\n                        return method.accounts.signTransaction(txOptions, wallet.privateKey)\n                            .then(sendSignedTx)\n                            .catch(function(err) {\n                                if (_.isFunction(defer.eventEmitter.listeners) && defer.eventEmitter.listeners('error').length) {\n                                    defer.eventEmitter.emit('error', err);\n                                    defer.eventEmitter.removeAllListeners();\n                                    defer.eventEmitter.catch(function() {\n                                    });\n                                }\n                                defer.reject(err);\n                            });\n                    }\n\n                    // ETH_SIGN\n                } else if (payload.method === 'eth_sign') {\n                    var data = payload.params[1];\n                    wallet = getWallet(payload.params[0], method.accounts);\n\n                    // If wallet was found, sign tx, and send using sendRawTransaction\n                    if (wallet && wallet.privateKey) {\n                        var sign = method.accounts.sign(data, wallet.privateKey);\n\n                        if (payload.callback) {\n                            payload.callback(null, sign.signature);\n                        }\n\n                        defer.resolve(sign.signature);\n                        return;\n                    }\n\n\n                }\n            }\n\n            return method.requestManager.send(payload, sendTxCallback);\n        };\n\n        // Send the actual transaction\n        if (isSendTx && _.isObject(payload.params[0]) && typeof payload.params[0].gasPrice === 'undefined') {\n\n            var getGasPrice = (new Method({\n                name: 'getGasPrice',\n                call: 'eth_gasPrice',\n                params: 0\n            })).createFunction(method.requestManager);\n\n            getGasPrice(function(err, gasPrice) {\n\n                if (gasPrice) {\n                    payload.params[0].gasPrice = gasPrice;\n                }\n                sendRequest(payload, method);\n            });\n\n        } else {\n            sendRequest(payload, method);\n        }\n\n\n        return defer.eventEmitter;\n    };\n\n    // necessary to attach things to the method\n    send.method = method;\n    // necessary for batch requests\n    send.request = this.request.bind(this);\n    return send;\n};\n\n/**\n * Should be called to create the pure JSONRPC request which can be used in a batch request\n *\n * @method request\n * @return {Object} jsonrpc request\n */\nMethod.prototype.request = function() {\n    var payload = this.toPayload(Array.prototype.slice.call(arguments));\n    payload.format = this.formatOutput.bind(this);\n    return payload;\n};\n\nmodule.exports = Method;\n"]},"metadata":{},"sourceType":"script"}